name: Deploy app to AWS

on:
  workflow_dispatch:
  # push:
  #   branches: [main]
  #   paths: ["infrastructure/app-infrastructure/**"]

  # pull_request:
  #   branches: [main]
  #   paths: ["infrastructure/app-infrastructure/**"]

env:
  AWS_REGION: "us-east-1"
  TERRAFORM_VERSION: "1.5.0"
  NODE_VERSION: "21"
  JAVA_VERSION: "17"

permissions:
      id-token: write
      contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Git clone the repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1.7.0
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: ${{ env.NODE_VERSION }}

      # Setup Java for backend build
      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      # Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      # Initialize and apply Terraform
      - name: Deploy Terraform project
        working-directory: ./infrastructure/app-infrastructure
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=app/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="encrypt=true" \
            -backend-config="dynamodb_table=${{ secrets.TERRAFORM_LOCK_TABLE }}"
          terraform plan -var="aws_region=${{ env.AWS_REGION }}" \
                        -var="db_name=${{ secrets.DB_NAME }}" \
                        -var="db_username=${{ secrets.DB_USERNAME }}" \
                        -var="db_password=${{ secrets.DB_PASSWORD }}" \
                        -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Build and push migration image
        working-directory: ./app-code/database
        run: |
          # Get ECR repository URL from Terraform output
          echo "no"
          ECR_REPO=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecr_repository_url)
          echo "yes"
          MIGRATION_TAG="${ECR_REPO}:migration"
          
          # Create Dockerfile for migration
          cat > Dockerfile.migration << 'EOF'
          FROM postgres:15
          COPY ./init.sql /app/database/
          COPY ./data/ /app/database/data/
          EOF
          
          # Build and push migration image
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REPO
          docker build -f Dockerfile.migration -t $MIGRATION_TAG .
          docker push $MIGRATION_TAG

      # Deploy database
      - name: Deploy database
        working-directory: ./app-code/database
        run: |
          # Get resource values from Terraform outputs
          DB_ENDPOINT=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw db_endpoint)
          ECS_CLUSTER=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecs_cluster_name)
          SECURITY_GROUP_ID=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecs_security_group_id)
          SUBNET_ID=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw private_subnet_id)
          ECR_REPO=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecr_repository_url)
          ECS_TASK_EXECUTION_ROLE_ARN=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecs_task_execution_role_arn)
          
          # Create a temporary task definition
          TASK_DEF_FAMILY="db-migration-$(date +%s)"
          aws ecs register-task-definition \
            --family $TASK_DEF_FAMILY \
            --network-mode awsvpc \
            --requires-compatibilities FARGATE \
            --cpu 256 \
            --memory 512 \
            --execution-role-arn $ECS_TASK_EXECUTION_ROLE_ARN \
            --container-definitions '[
              {
                "name": "db-migration",
                "image": "postgres:15",
                "essential": true,
                "environment": [
                  {
                    "name": "PGPASSWORD",
                    "value": "'${{ secrets.DB_PASSWORD }}'"
                  }
                ]
              }
            ]'
          
          # Run the migration task
          TASK_ARN=$(aws ecs run-task \
            --cluster $ECS_CLUSTER \
            --task-definition $TASK_DEF_FAMILY \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=DISABLED}" \
            --overrides '{
              "containerOverrides": [{
                "name": "db-migration",
                "command": ["psql", "-h", "'$DB_ENDPOINT'", "-U", "'${{ secrets.DB_USERNAME }}'", "-d", "'${{ secrets.DB_NAME }}'", "-f", "/app/database/init.sql"]
              }]
            }' \
            --query 'tasks[0].taskArn' \
            --output text)
          
          # Wait for task completion
          echo "Waiting for migration task to complete..."
          aws ecs wait tasks-stopped --cluster $ECS_CLUSTER --tasks $TASK_ARN
          
          # Check task status
          TASK_STATUS=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --query 'tasks[0].containers[0].exitCode' \
            --output text)
          
          # Clean up the task definition
          aws ecs deregister-task-definition \
            --task-definition $TASK_DEF_FAMILY:1
          
          if [ "$TASK_STATUS" != "0" ]; then
            echo "Migration task failed with status $TASK_STATUS"
            exit 1
          fi

      # Build and deploy backend
      - name: Build and deploy backend
        working-directory: ./app-code/backend
        run: |
          # Build the application
          ./mvnw clean package -DskipTests
          
          # Get ECR repository URL from Terraform output
          ECR_REPO=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecr_repository_url)
          
          # Build and push Docker image
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REPO
          docker build -t $ECR_REPO:latest .
          docker push $ECR_REPO:latest
          
          # Update ECS service to pick up new image
          aws ecs update-service --cluster $(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecs_cluster_name) \
                                --service $(terraform -chdir=../../infrastructure/app-infrastructure output -raw ecs_service_name) \
                                --force-new-deployment

      # Build and deploy frontend
      - name: Build and deploy frontend
        working-directory: ./app-code/frontend
        run: |
          # Get Cognito user pool ID and client ID from Terraform output
          COGNITO_USER_POOL_ID=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw user_pool_id)
          COGNITO_USER_POOL_CLIENT_ID=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw user_pool_client_id)

          # Create environment file
          cat << EOF > src/environments/environment.prod.ts
          export const environment = {
            production: true,
            cognito: {
              userPoolId: '$COGNITO_USER_POOL_ID',
              userPoolClientId: '$COGNITO_USER_POOL_CLIENT_ID'
            }
          };
          EOF

          # Install dependencies and build
          npm install
          npm run build
          
          # Get S3 bucket name from Terraform output
          S3_BUCKET=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw frontend_bucket_name)
          
          # Deploy to S3
          aws s3 sync build/ s3://$S3_BUCKET/
          
          # Invalidate CloudFront cache
          DISTRIBUTION_ID=$(terraform -chdir=../../infrastructure/app-infrastructure output -raw cloudfront_distribution_id)
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
